## DFS 
- DFS 和 BFS 经常在算法面试题当中出现，在整个算法面试知识点中所占的比重非常大。应用最多的地方就是对图进行遍历，树也是图的一种。
- DFS思路：
  DFS 解决的是连通性的问题，即，给定两个点，一个是起始点，一个是终点，判断是不是有一条路径能从起点连接到终点。起点和终点，也可以指的是某种起始状态和最终的状态。问题的要求并不在乎路径是长还是短，只在乎有还是没有。有时候题目也会要求把找到的路径完整的打印出来。
#### DFS递归代码:
递归实现：

  1. 代码看上去很简洁；

  2. 实际应用中，递归需要压入和弹出栈，栈深的时候会造成运行效率低下。
```Java
boolean dfs(int maze[][], int x, int y) {
    // 第一步：判断是否找到了B
    if (x == B[0] && y == B[1]) {
        return true;
    } 

    // 第二步：标记当前的点已经被访问过
    maze[x][y] = -1;

    // 第三步：在四个方向上尝试
    for (int d = 0; d < 4; d++) {
        int i = x + dx[d], j = y + dy[d];

        // 第四步：如果有一条路径被找到了，返回true
        if (isSafe(maze, i, j) && dfs(maze, i, j)) {
            return true;
        }
    }

    // 付出了所有的努力还是没能找到B，返回false
    return false;
  
}
```

非递归实现：

  1. 栈支持压入和弹出；

  2. 栈能提高效率。

```Java
boolean dfs(int maze[][], int x, int y) {
    // 创建一个Stack
    Stack<Integer[]> stack = new Stack<>();

    // 将起始点压入栈，标记它访问过
    stack.push(new Integer[] {x, y});
    maze[x][y] = -1;
    
    while (!stack.isEmpty()) {
        // 取出当前点
        Integer[] pos = stack.pop();
        x = pos[0]; y = pos[1];
      
        // 判断是否找到了目的地
        if (x == B[0] && y == B[1]) {
          return true;
        }
    
        // 在四个方向上尝试  
        for (int d = 0; d < 4; d++) {
            int i = x + dx[d], j = y + dy[d];
            
        if (isSafe(maze, i, j)) {
            stack.push(new Integer[] {i, j});
            maze[i][j] = -1;
            }
        }
    }
    return false;
}
```

#### 算法分析

DFS 是图论里的算法，分析利用 DFS 解题的复杂度时，应当借用图论的思想。图有两种表示方式：邻接表、邻接矩阵。假设图里有 V 个顶点，E 条边。

- 时间复杂度：

  - 邻接表

    访问所有顶点的时间为 O(V)，而查找所有顶点的邻居一共需要 O(E) 的时间，所以总的时间复杂度是 O(V + E)。

  - 邻接矩阵

    查找每个顶点的邻居需要 O(V) 的时间，所以查找整个矩阵的时候需要 O(V2) 的时间。

    举例：利用 DFS 在迷宫里找一条路径的复杂度。迷宫是用矩阵表示。
    
    解法：把迷宫看成是邻接矩阵。假设矩阵有 M 行 N 列，那么一共有 M × N 个顶点，因此时间复杂度就是 O(M × N)。

- 空间复杂度：

  DFS 需要堆栈来辅助，在最坏情况下，得把所有顶点都压入堆栈里，所以它的空间复杂度是 O(V)，即 O(M × N)。
  
  
## BFS
  广度优先搜索，一般用来解决最短路径的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。
  
  广度优先的搜索可以同时从起始点和终点开始进行，称之为双端 BFS。这种算法往往可以大大地提高搜索的效率。
  - 举例：在社交应用程序中，两个人之间需要经过多少个朋友的介绍才能互相认识对方。
  解法：
    1. 只从一个方向进行 BFS，有时候这个人认识的朋友特别多，那么会导致搜索起来非常慢；

    2. 如果另外一方认识的人比较少，从这一方进行搜索，就能极大地减少搜索的次数；

    3. 每次在决定从哪一边进行搜索的时候，要判断一下哪边认识的人比较少，然后从那边进行搜索。
#### 代码实现
```Java
void bfs(int[][] maze, int x, int y) {
    // 创建一个队列queue，将起始点A加入队列中
    Queue<Integer[]> queue = new LinkedList<>();
    queue.add(new Integer[] {x, y});
  
    // 只要队列不为空就一直循环下去  
    while (!queue.isEmpty()) {
        // 从队列的头取出当前点
        Integer[] pos = queue.poll();
        x = pos[0]; y = pos[1];
      
        // 从四个方向进行BFS
        for (int d = 0; d < 4; d++) {
            int i = x + dx[d], j = y + dy[d];
        
            if (isSafe(maze, i, j)) {
                // 记录步数（标记访问过）
                maze[i][j] = maze[x][y] + 1;
                // 然后添加到队列中  
                queue.add(new Integer[] {i, j});
                // 如果发现了目的地就返回  
                if (i == B[0] && j == B[1]) return;
            }
        }
    }
}
```

####算法分析

同样借助图论的分析方法，假设有 V 个顶点，E 条边。

- 时间复杂度：

  - 邻接表

    每个顶点都需要被访问一次，时间复杂度是 O(V)；相连的顶点（也就是每条边）也都要被访问一次，加起来就是 O(E)。因此整体时间复杂度就是 O(V+E)。

  - 邻接矩阵

    V 个顶点，每次都要检查每个顶点与其他顶点是否有联系，因此时间复杂度是 O(V2)。

 

  举例：在迷宫里进行 BFS 搜索。

  解法：用邻接矩阵。假设矩阵有 M 行 N 列，那么一共有 M×N 个顶点，时间复杂度就是 O(M×N)。

- 空间复杂度：

  需要借助一个队列，所有顶点都要进入队列一次，从队列弹出一次。在最坏的情况下，空间复杂度是 O(V)，即 O(M×N)。


