## 递归和回溯的关系密不可分：

- 递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。

- 回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。

## 递归解题模板和代码实现

  1. 判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。

  2. 判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。

  3. 将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。

  4. 利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。

```Java
function fn(n) {
    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
    }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
    }

    // 第三步：缩小问题规模
    result1 = fn(n1)
    result2 = fn(n2)
    ...

    // 第四步: 整合结果
    return combine(result1, result2)
}
```

## 算法分析
- 分析递归算法推荐两种方法：
  - 1. 迭代法
  - 2. 公式法
  
公式法可以说是计算递归函数复杂度最方便的工具，当递归函数的时间执行函数满足如下的关系式时，我们可以利用公式法：T(n) = a×T(n/b) + f(n)。
其中，f(n) 是每次递归完毕之后额外的计算执行时间。例如，在归并排序中，每次递归处理完两边的数组后，我们需要执行合并的操作，那么这个操作的执行时间就是 f(n)。
当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(n^logba)。

**由于时间复杂度求的是上界（upper bound)，通过对比递归部分的时间复杂度和 f(n) 的大小关系，得出最后的整体时间复杂度。牢记以下三种情况和相应公式：**
  - 当递归部分的执行时间 nlog(b)a 大于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)。

  - 当递归部分的执行时间 nlog(b)a 小于 f(n) 的时候，最终的时间复杂度就是 f(n)。

  - 当递归部分的执行时间 nlog(b)a 等于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)logn。
  
## 回溯算法的思想
回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。
回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。

## 回溯算法的解题模板
- 1. 判断当前情况是否非法，如果非法就立即返回；

- 2. 当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；

- 3. 当前情况下，遍历所有可能出现的情况并进行下一步的尝试；

- 4. 递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。

```Java
function fn(n) {

    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
  }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
  }

    // 遍历所有可能出现的情况
    for (all possible cases) {
  
        // 第三步: 尝试下一步的可能性
        solution.push(case)
        // 递归
        result = fn(m)

        // 第四步：回溯到上一步
        solution.pop(case)
    
    }
    
}
```

## 8皇后回溯算法分析：

每次都必须遍历所有的列，一共有 n 列。

在每次遍历中，先要利用 check 函数检查当前的摆放方法会不会产生冲突，检查的时间复杂度由当前所在的行决定，上限是 n，所以总时间复杂度就是 O(n2)。

递归地尝试着每种摆放，当我们放好了第一个皇后，剩下要处理的之后 n-1 个皇后，问题的规模减少了一个，于是执行时间变成了 T(n - 1)。

 

最终得到了 T(n) 的表达式：T(n) = n×T(n - 1) + O(n2)。

 

利用迭代法将 T(n) 展开得到：

 

T(n) = n×((n - 1)×T(n - 2) +  (n - 1)2 + n2

…

T(n) = n×(n - 1)×(n - 2)× … ×1 + 1 + 22 + 32 + … (n - 1)2 + n2

 

前面一部分是阶乘，后面一部分是平方求和，根据公式最后得到：

 

T(n) = n! + n(n+1)(2n+1)/6

 

O(T(n)) = n! + O(n3)

 

由于 n!>n3，因此，它的上界就是 n!，即：O(T(n)) = n!


## Additional (!Important)

回溯法通用框架：
```Java
void backtrack (int t)  
{  
    if (t>n)   
        output(x); //已到叶子结点，输出结果  
    else  
        // f(n,t),g(n,t)表示当前扩展结点处未搜索过的子树的起始编号和终止编号
        for (int i=f(n,t);i<=g(n,t);i++) {  
            x[t]=h(i); // h(i)：表示在当前扩展结点处x[t]的第i个可选值
            //constraint(t)为true表示在当前扩展结点处x[1:t]的取值满足问题的约束条件
            //bound(t)为true表示在当前扩展结点处x[1:t]的取值尚未导致目标函数越界
            if (constraint(t)&&bound(t))  
                backtrack(t+1);  
        }  
}
```

用回溯法解题时常用到两种典型的解空间树：子集树与排列树

- 第一类解空间树：子集树 
  1. 当问题是：从n个元素的集合S中找出满足某种性质的子集时,相应的解空间树称为子集树
  2. 例如n个物品的0/1背包问题，这类子集树通常有2n2n个叶结点，解空间树的结点总数为2n+1−12n+1−1，遍历子集树的算法需Ω(2n2n)计算时间
  3. 子集树回溯算法框架：
```Java
void backtrack (int t) {
    if (t > n){
        output(x);
    }
    else{
    // 对当前扩展结点的所有可能取值进行枚举
        for (int i = 0; i <= 1; i++) {
            x[t] = i;
            if (constraint(t) && bound(t)) backtrack(t+1);
        }
    }
}// 执行时，从Backtrack(1)开始
```
- 第二类解空间树：排列树 
  1. 当问题是：确定n个元素满足某种性质的排列时，相应的解空间树称为排列树
  2. 例如旅行商问题，排列树通常有n！个叶结点，因此遍历排列树需要Ω(n!)计算时间
  3. 排列树回溯算法框架：
```Java
void backtrack (int t) {
    if (t > n){
        output(x);
    }
    else{
        for (int i = t; i <= n; i++) {
            swap(x[t], x[i]);
            if (constraint(t) && bound(t)) backtrack(t+1);
            swap(x[t], x[i]);
        }
    }
} // 调用Backtrack(1)前，首先将数组x初始化为单位排列[1,2, ..., n]
```


## Reference
https://blog.csdn.net/u010089444/article/details/53908003 (important)
