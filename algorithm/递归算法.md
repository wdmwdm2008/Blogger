2、递归

　　递归是设计和描述算法的一种有力的工具，由于它在复杂算法的描述中被经常采用，为此在进一步介绍其他算法设计方法之前先讨论它。能采用递归描述的算法通常有这样的特征：为求解规模为N的问题，设法将它分解成规模较小的问题，然后从这些小问题的解方便地构造出大问题的解，并且这些规模较小的问题也能采用同样的分解和综合方法，分解成规模更小的问题，并从这些更小问题的解构造出规模较大问题的解。特别地，当规模N=1时，能直接得解。【MengMa: 递归Recursion和迭代Iteration都是具体的实现，而不是设计方法。】

　　【问题】 编写计算斐波那契（Fibonacci）数列的第n项函数fib（n）。

　　斐波那契数列为：0、1、1、2、3、……，即：

　　fib(0)=0;
　　fib(1)=1;
　　fib(n)=fib(n-1)+fib(n-2) （当n>1时）。

　　写成递归函数有：
int fib(int n)
{
　　if (n==0) return 0;
　　if (n==1) return 1;
　　if (n>1) return fib(n-1)+fib(n-2);
}
复制代码

3、组合问题
【MengMa: 原作者并没展开讨论组合问题， 我补充一下吧】
组合问题有好多种，LeetCode里也有很多组合问题以及变形。这种题目看似麻烦，实际可以通过递归来解决。需要注意的是：
递归传递的变量，在递归函数前和递归函数后需要保持一致，也就是说需要恢复原状。（如果每次调用递归就new一个新变量出来会耗费大量空间）
否则递归函数就不正确了（比如Combination Sum 题目）
Permutations, Combination Sum等等。。
关于组合问题扫盲：
ACM之递归很重要
ACM递归与分治策略
【/MengMa】

4、 背包问题
　　问题描述：有不同价值、不同重量的物品n件，求从这n件物品中选取一部分物品的选择方案，使选中物品的总重量不超过指定的限制重量，但选中物品的价值之和最大。

　　设n 件物品的重量分别为w0、w1、…、wn-1，物品的价值分别为v0、v1、…、vn-1。采用递归寻找物品的选择方案。设前面已有了多种选择的方案，并保留了其中总价值最大的方案于数组option[ ]，该方案的总价值存于变量maxv。当前正在考察新方案，其物品选择情况保存于数组cop[ ]。假定当前方案已考虑了前i-1件物品，现在要考虑第i件物品；当前方案已包含的物品的重量之和为tw；至此，若其余物品都选择是可能的话，本方案能达到的总价值的期望值为tv。算法引入tv是当一旦当前方案的总价值的期望值也小于前面方案的总价值maxv时，继续考察当前方案变成无意义的工作，应终止当前方案，立即去考察下一个方案。因为当方案的总价值不比maxv大时，该方案不会被再考察，这同时保证函数后找到的方案一定会比前面的方案更好。

　　对于第i件物品的选择考虑有两种可能：

　　（1） 考虑物品i被选择，这种可能性仅当包含它不会超过方案总重量限制时才是可行的。选中后，继续递归去考虑其余物品的选择。

　　（2） 考虑物品i不被选择，这种可能性仅当不包含物品i也有可能会找到价值更大的方案的情况。

　　按以上思想写出递归算法如下：

　　try(物品i，当前选择已达到的重量和，本方案可能达到的总价值tv)

　　{ /*考虑物品i包含在当前方案中的可能性*/

　　if(包含物品i是可以接受的)

　　{ 将物品i包含在当前方案中；

　　if (i

　　try(i+1,tw+物品i的重量,tv);

　　else

　　/*又一个完整方案，因为它比前面的方案好，以它作为最佳方案*/

　　以当前方案作为临时最佳方案保存;

　　恢复物品i不包含状态；

　　}

　　/*考虑物品i不包含在当前方案中的可能性*/

　　if (不包含物品i仅是可男考虑的)

　　if (i

　　try(i+1,tw,tv-物品i的价值)；

　　else

　　/*又一个完整方案，因它比前面的方案好，以它作为最佳方案*/

　　以当前方案作为临时最佳方案保存;

　　}

　　为了理解上述算法，特举以下实例。设有4件物品，它们的重量和价值见表：

　　物品 0 1 2 3

　　重量 5 3 2 1

　　价值 4 4 3 1

　　并设限制重量为7。则按以上算法，下图表示找解过程。由图知，一旦找到一个解，算法就进一步找更好的佳。如能判定某个查找分支不会找到更好的解，算法不会在该分支继续查找，而是立即终止该分支，并去考察下一个分支。

　　
　　递归的基本概念和特点

　　程序调用自身的编程技巧称为递归（ recursion）。

　　一个过程或函数在其定义或说明中又直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。用递归思想写出的程序往往十分简洁易懂。

　　一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

　　注意：

　　(1) 递归就是在过程或函数里调用自身;

　　(2) 在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。
